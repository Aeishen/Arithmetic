/*
   @File: KthGrammar
   @Author: Aeishen
   @Date: 2019/12/25 17:02
   @Description:
*/

/*
题目：
	在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。
	给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）

示例:
	输入: N = 1, K = 1
	输出: 0

	输入: N = 2, K = 1
	输出: 0

	输入: N = 2, K = 2
	输出: 1

	输入: N = 4, K = 5
	输出: 1

	解释:
	第一行: 0
	第二行: 01
	第三行: 0110
	第四行: 01101001

注意：
	N 的范围 [1, 30].
	K 的范围 [1, 2^(N-1)].

思路：
    暴力：我们完全按照题目描述中的指示处理每一行，而只需要保存最新的那一行。不幸的是，字符串的长度可能有 10 亿左右，因为每一行的长度都是前一行的两倍，所以这种方法不够高效。
			时间复杂度：O(2^N)，我们解析每一行所需要的时间和其长度有关，共计 2^0 + 2^1 + ... + 2^{N-1}
			空间复杂度：O(2^N)，最后一行（lastrow）的长度。

	递归（父变体）：因为生成每一行只需要前一行的信息，所以我们可以考虑解析前一行的位来输出答案。来看这个例子，如果我们中间有一行是 "0110"，
          那么就会生成 "01101001" 作为它的下一行，也就是说第一位 "0" 生成下一行中的第一个 "01"，第二位 "1" 生成下一行中的 "10"，
          接着 "1" 又生成了 "10"，而最后的 "0" 将会生成最后的 "01"。
          一般而言，第 K 位的父位应该是第 (K+1) / 2 位。如果父位是 0，那么这一位就是 1 - (K%2)。如果父位是 1，那么这一位就是 K%2。
			时间复杂度：O(N)。找出答案需要 N-1N−1 步。
			空间复杂度：O(1)。

	递归（翻转变体）:就像在父变体中那样，我们可以尝试按它前面的位来写出这一位。如果我们写出该序列中的几行，就可以发现：后半部分总是与
		前半部分相反，也就是说：'0' 变成 '1' 而 '1' 变成 '0'。我们可以用归纳法来验证这一推断。其关键思想是，如果字符串 XX 生成 YY，
    	那么翻转后的字符串 X′将会生成 Y′。这就引出了下面的算法思想：如果 K 在后半部分，那么我们可以将 K -= (1 << N-2) 设为前半部分，然后翻转得到最终答案。
			时间复杂度：O(N)。找出答案需要 N-1N−1 步。
			空间复杂度：O(1)。

*/
package main

import (
	"fmt"
)

func main() {
	fmt.Println(kthGrammar1(4, 5))
}

// 递归（父变体）
func kthGrammar1(N int, K int) int {
	if N == 1{
		return 0
	}
	return (1 - K % 2) ^ kthGrammar1( N - 1, (K + 1) / 2)
}

// 递归（翻转变体）
func kthGrammar2(N int, K int) int {
}

