/*
@author : Aeishen
@data :  19/08/05, 16:34
@description :
*/

/*
题目：设计一个公平的洗牌算法

分析：
1. 洗牌，显然是一个随机算法了。随机算法还不简单？把所有牌放到一个数组中，每次取两张牌交换位置，随机k次即可。但是k要取多少次才合适？？？
   如果数组中有 1000000 个元素，随机 100 次太少；如果数组中只有 10 个元素，随机 10000 次又太多。一个合理的选择是，随机次数和数组中元
   素大小相关。比如数组有多少个元素，我们就随机多少次。但其实，这个答案连这个问题的本质"公平"都没有触及到

2. 先弄清楚什么是"公平"，洗牌的结果是所有元素的一个排列。一副牌如果有 n 个元素，最终排列的可能性一共有 n! 个。公平的洗牌算法，应该能等
   概率地给出这 n! 个结果中的任意一个。如思考到这一点，我们就能设计出一个简单的暴力算法了：对于 n 个元素，生成所有的 n! 个排列，然后，
   随机抽一个。这个算法绝对是公平的。但问题是，复杂度太高。复杂度是多少呢？O(n!)。因为，n 个元素一共有 n! 种排列，我们求出所有 n! 种排
   列，至少需要 n! 的时间。O(2^n) 已经被称为指数爆炸了。O(n!) 不可想象。

3. 换一个角度思考"公平"这个话题，其实，我们也可以认为，公平是指，对于生成的排列，每一个元素都能等概率地出现在每一个位置。或者反过来，
   每一个位置都能等概率地放置每个元素。基于这个定义，我们就可以给出一个简单的算法了。
*/

package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().Unix())
	cards := []int{1,2,3,4}
	for i := 0;i < 10 ;i++{
		shuffle(cards)
		fmt.Println(cards)
	}
}

//这个算法就是大名鼎鼎的 Knuth-Shuffle，即 Knuth 洗牌算法。整个算法的复杂度是 O(n) 的。
//在整个过程中，每一个元素出现在每一个位置的概率都是相同的，为 1 / n
func shuffle(cards []int){
	cardsCount := len(cards)
	for i := cardsCount - 1; i >= 0; i--{
		j := rand.Int() % (i + 1)    // 要对 i + 1 取余，保证随机的索引在 [0...i] 之间。
		swapCards(cards, i, j)
	}
}

func swapCards(cards []int, i int,j int){
	cards[i],cards[j] = cards[j],cards[i]
}


